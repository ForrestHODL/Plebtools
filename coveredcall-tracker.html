<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Covered Call Tracker - Plebtools</title>
  <link rel="icon" type="image/x-icon" href="images/channels4_profile.jpg">
  <link rel="stylesheet" href="styles.css?v=3">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <style>
    /* Covered Call Tracker Styles */
    .tracker-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      background: white;
      min-height: 100vh;
    }

    .tracker-header {
      text-align: center;
      margin-bottom: 3rem;
      padding: 2rem 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }

    .tracker-title {
      font-size: 2.5rem;
      font-weight: bold;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .tracker-description {
      font-size: 1.2rem;
      opacity: 0.9;
      max-width: 600px;
      margin: 0 auto;
    }

    .tracker-interface {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .controls-panel {
      background: #f8f9fa;
      padding: 2rem;
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      height: fit-content;
    }

    .control-group {
      margin-bottom: 2rem;
    }

    .control-label {
      display: block;
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #333;
    }

    .control-input {
      width: 100%;
      padding: 0.8rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 1rem;
      transition: border-color 0.3s ease;
    }

    .control-input:focus {
      outline: none;
      border-color: #667eea;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    .form-actions {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    }

    .btn {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .btn-success {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
    }

    .btn-success:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
    }

    .btn-danger {
      background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
      color: white;
    }

    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #5a6268;
    }

    .visualization-panel {
      background: #f8f9fa;
      padding: 2rem;
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .chart-controls {
      margin-bottom: 1rem;
      text-align: center;
    }
    
    .chart-toggle-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.2s;
    }
    
    .chart-toggle-btn:hover {
      background: #0056b3;
    }
    
    .chart-container {
      position: relative;
      height: 400px;
      margin-bottom: 2rem;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: white;
      padding: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
      text-align: center;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: #667eea;
      margin-bottom: 0.5rem;
    }

    .stat-label {
      color: #666;
      font-size: 0.9rem;
    }

    .trades-table {
      background: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
    }

    .table {
      width: 100%;
      border-collapse: collapse;
    }

    .table th,
    .table td {
      padding: 1rem;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    .table th {
      background: #f8f9fa;
      font-weight: bold;
      color: #333;
    }

    .table tr:hover {
      background: #f8f9fa;
    }

    .profit {
      color: #28a745;
      font-weight: bold;
    }

    .loss {
      color: #dc3545;
      font-weight: bold;
    }

    .action-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .btn-sm {
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
    }

    /* Mobile responsiveness */
    @media (max-width: 768px) {
      .tracker-interface {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .tracker-title {
        font-size: 2rem;
      }

      .tracker-description {
        font-size: 1rem;
      }

      .controls-panel,
      .visualization-panel {
        padding: 1rem;
      }

      .form-row {
        grid-template-columns: 1fr;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    /* Dark theme support */
    .dark-theme .tracker-container {
      background: #2d2d2d;
    }

    .dark-theme .controls-panel,
    .dark-theme .visualization-panel {
      background: #3d3d3d;
    }

    .dark-theme .control-label {
      color: #e0e0e0;
    }

    .dark-theme .control-input {
      background: #4d4d4d;
      border-color: #555;
      color: #e0e0e0;
    }

    .dark-theme .stat-card {
      background: #4d4d4d;
    }

    .dark-theme .stat-label {
      color: #ccc;
    }

    .dark-theme .trades-table {
      background: #4d4d4d;
    }

    .dark-theme .table th {
      background: #3d3d3d;
      color: #e0e0e0;
    }

    .dark-theme .table td {
      color: #e0e0e0;
    }

    .dark-theme .table tr:hover {
      background: #3d3d3d;
    }
  </style>
</head>
<body>
  <header>
    <nav>
      <div class="nav-container">
        <div class="logo-container">
          <img src="images/plub tools image.jpeg" alt="Plebtools" class="nav-logo">
          <h1 class="logo">Plebtools</h1>
        </div>
        <div class="nav-links">
          <a href="home.html">Home</a>
          <a href="treasury.html">Treasury</a>
          <a href="btc-buy-tracker.html">Portfolio</a>
          <a href="press-release.html">Press Release</a>
          <a href="coveredcall-tracker.html" class="active">Covered Calls</a>
        </div>
      </div>
    </nav>
  </header>

  <main>
    <div class="tracker-container">
      <div class="tracker-header">
        <h1 class="tracker-title">Covered Call Tracker</h1>
        <p class="tracker-description">
          Track your covered call trades, monitor premium income, and visualize your cost basis adjustments. 
          Perfect for managing your options strategy and maximizing returns.
        </p>
      </div>

      <div class="tracker-interface">
        <div class="controls-panel">
          <h3 style="margin-bottom: 2rem; color: #333;">Add New Trade</h3>
          
          <form id="tradeForm">
            <div class="control-group">
              <label class="control-label" for="tradeType">Trade Type</label>
              <select id="tradeType" class="control-input" onchange="toggleSymbolFields()">
                <option value="shares">Share Purchase Only</option>
                <option value="covered-call">Covered Call Trade</option>
              </select>
            </div>

            <div class="control-group" id="symbolInputGroup">
              <label class="control-label" for="symbol">Stock Symbol</label>
              <input type="text" id="symbol" class="control-input" placeholder="e.g., AAPL" required>
            </div>

            <div class="control-group" id="symbolSelectGroup" style="display: none;">
              <label class="control-label" for="symbolSelect">Select Existing Position</label>
              <select id="symbolSelect" class="control-input" onchange="loadSelectedPosition()">
                <option value="">Choose a position...</option>
              </select>
            </div>

            <div class="form-row">
              <div class="control-group">
                <label class="control-label" for="shares">Shares</label>
                <input type="number" id="shares" class="control-input" placeholder="100" required>
              </div>
              <div class="control-group">
                <label class="control-label" for="costBasis">Cost Basis per Share</label>
                <input type="number" id="costBasis" class="control-input" placeholder="150.00" step="0.01" required>
              </div>
            </div>

            <div class="form-row">
              <div class="control-group">
                <label class="control-label" for="tradeDate">Trade Date</label>
                <input type="date" id="tradeDate" class="control-input" required>
              </div>
            </div>

            <div class="form-row" id="coveredCallFields" style="display: none;">
              <div class="control-group">
                <label class="control-label" for="strikePrice">Strike Price (Optional)</label>
                <input type="number" id="strikePrice" class="control-input" placeholder="155.00" step="0.01">
              </div>
              <div class="control-group">
                <label class="control-label" for="premium">Premium Received per Share (Optional)</label>
                <input type="number" id="premium" class="control-input" placeholder="2.50" step="0.01">
              </div>
            </div>

            <div class="control-group">
              <label class="control-label" for="notes">Notes (Optional)</label>
              <textarea id="notes" class="control-input" rows="3" placeholder="Add any notes about this trade..."></textarea>
            </div>

            <div class="form-actions">
              <button type="submit" class="btn btn-primary">Add Trade</button>
              <button type="button" class="btn btn-secondary" onclick="clearForm()">Clear</button>
            </div>
          </form>

          <div style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #e0e0e0;">
            <h4 style="margin-bottom: 1rem; color: #333;">Data Management</h4>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
              <button class="btn btn-success" onclick="exportData()">Export Data</button>
              <button class="btn btn-danger" onclick="clearAllData()">Clear All</button>
            </div>
          </div>
        </div>

        <div class="visualization-panel">
          <h3 style="margin-bottom: 2rem; color: #333;">Performance Overview</h3>
          
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" id="totalValue">$0.00</div>
              <div class="stat-label">Original Cost Basis</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="originalShareCost">$0.00</div>
              <div class="stat-label">Original Share Cost</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="totalPremium">$0.00</div>
              <div class="stat-label">Total Premium</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="totalAdjustedCostBasis">$0.00</div>
              <div class="stat-label">Total Adjusted Cost Basis</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="avgCostBasis">$0.00</div>
              <div class="stat-label">Avg Adjusted Cost Basis</div>
            </div>
          </div>

        <div class="chart-controls">
          <button id="chartToggle" class="chart-toggle-btn">Switch to Line Chart</button>
        </div>
        <div class="chart-container">
          <canvas id="performanceChart"></canvas>
        </div>

          <h4 style="margin-bottom: 1rem; color: #333;">Recent Trades</h4>
          <div class="trades-table">
            <table class="table">
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Symbol</th>
                  <th>Shares</th>
                  <th>Strike</th>
                  <th>Premium</th>
                  <th>New Cost Basis</th>
                  <th>P&L</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="tradesTableBody">
                <tr>
                  <td colspan="8" style="text-align: center; color: #666; padding: 2rem;">
                    No trades yet. Add your first trade above!
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </main>

  <footer>
    <div class="container">
      <p>&copy; 2024 Plebtools. Open source Bitcoin tracking tools.</p>
    </div>
  </footer>

  <script>
    // Global variables
    let trades = JSON.parse(localStorage.getItem('coveredCallTrades')) || [];
    let performanceChart = null;
    let chartType = 'bar'; // 'bar', 'line', or 'pie'

    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
      // Set default date to today
      const today = new Date().toISOString().split('T')[0];
      document.getElementById('tradeDate').value = today;
      
      loadTrades();
      updateStats();
      updateChart();
      updateTable();
    });

    // Form submission
    document.getElementById('tradeForm').addEventListener('submit', function(e) {
      e.preventDefault();
      addTrade();
    });

    // Chart toggle
    document.getElementById('chartToggle').addEventListener('click', function() {
      if (chartType === 'bar') {
        chartType = 'line';
        this.textContent = 'Switch to Pie Chart';
      } else if (chartType === 'line') {
        chartType = 'pie';
        this.textContent = 'Switch to Bar Chart';
      } else {
        chartType = 'bar';
        this.textContent = 'Switch to Line Chart';
      }
      updateChart();
    });

    // Toggle optional fields based on trade type
    function toggleSymbolFields() {
      const tradeType = document.getElementById('tradeType').value;
      const symbolInputGroup = document.getElementById('symbolInputGroup');
      const symbolSelectGroup = document.getElementById('symbolSelectGroup');
      const coveredCallFields = document.getElementById('coveredCallFields');
      
      if (tradeType === 'shares') {
        symbolInputGroup.style.display = 'block';
        symbolSelectGroup.style.display = 'none';
        coveredCallFields.style.display = 'none';
      } else {
        symbolInputGroup.style.display = 'none';
        symbolSelectGroup.style.display = 'block';
        coveredCallFields.style.display = 'block';
        updateSymbolSelect();
      }
    }

    // Update symbol select dropdown with existing positions
    function updateSymbolSelect() {
      const symbolSelect = document.getElementById('symbolSelect');
      const sharePositions = getSharePositions();
      
      // Clear existing options except the first one
      symbolSelect.innerHTML = '<option value="">Choose a position...</option>';
      
      // Add options for each unique symbol with shares
      sharePositions.forEach(position => {
        const option = document.createElement('option');
        option.value = position.symbol;
        option.textContent = `${position.symbol} (${position.totalShares} shares @ $${position.avgCostBasis.toFixed(2)})`;
        symbolSelect.appendChild(option);
      });
    }

    // Get all share positions (aggregated by symbol)
    function getSharePositions() {
      const shareTrades = trades.filter(trade => trade.tradeType === 'shares');
      const positionMap = new Map();
      
      shareTrades.forEach(trade => {
        if (positionMap.has(trade.symbol)) {
          const existing = positionMap.get(trade.symbol);
          const totalShares = existing.totalShares + trade.shares;
          const totalCost = (existing.avgCostBasis * existing.totalShares) + (trade.newCostBasis * trade.shares);
          existing.totalShares = totalShares;
          existing.avgCostBasis = totalCost / totalShares;
        } else {
          positionMap.set(trade.symbol, {
            symbol: trade.symbol,
            totalShares: trade.shares,
            avgCostBasis: trade.newCostBasis
          });
        }
      });
      
      return Array.from(positionMap.values());
    }

     // Load selected position data
     function loadSelectedPosition() {
       const selectedSymbol = document.getElementById('symbolSelect').value;
       if (!selectedSymbol) return;
       
       const position = getSharePositions().find(p => p.symbol === selectedSymbol);
       if (position) {
         document.getElementById('shares').value = position.totalShares;
         document.getElementById('costBasis').value = position.avgCostBasis.toFixed(2);
         document.getElementById('symbol').value = selectedSymbol;
         
         // Trigger input events to ensure form validation recognizes the values
         document.getElementById('shares').dispatchEvent(new Event('input', { bubbles: true }));
         document.getElementById('costBasis').dispatchEvent(new Event('input', { bubbles: true }));
       }
     }

    // Add new trade
    function addTrade() {
      const tradeType = document.getElementById('tradeType').value;
      const symbol = tradeType === 'covered-call' ? 
        document.getElementById('symbolSelect').value.toUpperCase() : 
        document.getElementById('symbol').value.toUpperCase();
      const shares = parseInt(document.getElementById('shares').value);
      const costBasis = parseFloat(document.getElementById('costBasis').value);
      const strikePrice = parseFloat(document.getElementById('strikePrice').value) || 0;
      const premiumPerShare = parseFloat(document.getElementById('premium').value) || 0;
      const tradeDate = document.getElementById('tradeDate').value;
      const expirationDate = '';
      const currentPrice = 0;
      const notes = document.getElementById('notes').value;

      // Calculate total premium and new cost basis
      const totalPremium = premiumPerShare * shares;
      let newCostBasis = costBasis;
      
      if (premiumPerShare > 0) {
        // For covered calls, calculate cumulative adjusted cost basis
        if (tradeType === 'covered-call') {
          // Get all existing trades for this symbol
          const existingTrades = trades.filter(t => t.symbol === symbol);
          const shareTrades = existingTrades.filter(t => t.tradeType === 'shares');
          const callTrades = existingTrades.filter(t => t.tradeType === 'covered-call');
          
          // Calculate total shares and total original cost basis
          let totalShares = 0;
          let totalOriginalCostBasis = 0;
          let totalPremiumReceived = 0;
          
          shareTrades.forEach(t => {
            totalShares += t.shares;
            totalOriginalCostBasis += t.originalCostBasis * t.shares;
          });
          
          callTrades.forEach(t => {
            totalPremiumReceived += (t.premium || 0);
          });
          
          // Add current premium
          totalPremiumReceived += totalPremium;
          
          if (totalShares > 0) {
            const avgOriginalCostBasis = totalOriginalCostBasis / totalShares;
            newCostBasis = avgOriginalCostBasis - (totalPremiumReceived / totalShares);
            console.log(`Cumulative cost basis calculation: ${avgOriginalCostBasis} - ${totalPremiumReceived / totalShares} = ${newCostBasis}`);
          }
        } else {
          // For share purchases, premium reduces cost basis per share
          newCostBasis = costBasis - premiumPerShare;
          console.log(`Cost basis calculation: ${costBasis} - ${premiumPerShare} = ${newCostBasis}`);
        }
      }
      
      // Calculate P&L
      const totalCostBasis = newCostBasis * shares;
      const currentValue = currentPrice * shares;
      const pnl = currentValue - totalCostBasis;

      const trade = {
        id: Date.now(),
        tradeType,
        symbol,
        shares,
        originalCostBasis: costBasis,
        newCostBasis: newCostBasis,
        strikePrice: strikePrice || null,
        premium: totalPremium || null,
        expirationDate: expirationDate || null,
        currentPrice,
        notes,
        pnl,
        dateAdded: tradeDate ? new Date(tradeDate).toISOString() : new Date().toISOString()
      };

      trades.push(trade);
      localStorage.setItem('coveredCallTrades', JSON.stringify(trades));
      
      loadTrades();
      updateStats();
      updateChart();
      updateTable();
      clearForm();
    }

    // Load trades from localStorage
    function loadTrades() {
      trades = JSON.parse(localStorage.getItem('coveredCallTrades')) || [];
    }

    // Update statistics
    function updateStats() {
      const totalPremium = trades.reduce((sum, trade) => sum + (trade.premium || 0), 0);
      
      // Calculate portfolio value based on current positions
      const positions = getSharePositions();
      let totalValue = 0;
      let totalCostBasis = 0;
      let totalAdjustedCostBasis = 0;

      positions.forEach(position => {
        // Get the most recent current price for this symbol
        const latestTrade = trades
          .filter(trade => trade.symbol === position.symbol)
          .sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded))[0];
        
        if (latestTrade && latestTrade.currentPrice > 0) {
          totalValue += latestTrade.currentPrice * position.totalShares;
        } else {
          // If no current price, use the cost basis as fallback
          totalValue += position.avgCostBasis * position.totalShares;
        }
        
        // Calculate adjusted cost basis (original cost basis minus premium received)
        const symbolTrades = trades.filter(trade => trade.symbol === position.symbol);
        const totalPremiumReceived = symbolTrades.reduce((sum, trade) => sum + (trade.premium || 0), 0);
        const adjustedCostBasisPerShare = position.avgCostBasis - (totalPremiumReceived / position.totalShares);
        
        totalCostBasis += position.avgCostBasis * position.totalShares;
        totalAdjustedCostBasis += Math.max(0, adjustedCostBasisPerShare) * position.totalShares;
      });
      
      const avgCostBasis = positions.length > 0 ? 
        totalCostBasis / positions.reduce((sum, pos) => sum + pos.totalShares, 0) : 0;
      
      const avgAdjustedCostBasis = positions.length > 0 ? 
        totalAdjustedCostBasis / positions.reduce((sum, pos) => sum + pos.totalShares, 0) : 0;

      console.log('Portfolio stats update:', {
        totalPremium,
        avgCostBasis,
        totalValue,
        totalAdjustedCostBasis,
        positions: positions.length
      });

      // Calculate original share cost (average cost per share)
      const shareTrades = trades.filter(t => t.tradeType === 'shares');
      const originalShareCost = shareTrades.length > 0 ? 
        shareTrades.reduce((sum, trade) => sum + trade.originalCostBasis, 0) / shareTrades.length : 0;

      document.getElementById('totalPremium').textContent = `$${totalPremium.toFixed(2)}`;
      document.getElementById('avgCostBasis').textContent = `$${avgAdjustedCostBasis.toFixed(2)}`;
      document.getElementById('totalValue').textContent = `$${totalValue.toFixed(2)}`;
      document.getElementById('totalAdjustedCostBasis').textContent = `$${totalAdjustedCostBasis.toFixed(2)}`;
      document.getElementById('originalShareCost').textContent = `$${originalShareCost.toFixed(2)}`;
    }

    // Update chart
    function updateChart() {
      const ctx = document.getElementById('performanceChart').getContext('2d');
      
      if (performanceChart) {
        performanceChart.destroy();
      }

      // Sort trades by date and use dates as labels
      const sortedTrades = [...trades].sort((a, b) => new Date(a.dateAdded) - new Date(b.dateAdded));
      const labels = sortedTrades.map(trade => {
        const date = new Date(trade.dateAdded);
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });
      
      // Create tooltip labels that include symbol
      const tooltipLabels = sortedTrades.map(trade => {
        const date = new Date(trade.dateAdded);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        return `${trade.symbol} - ${dateStr}`;
      });
      const premiumData = sortedTrades.map(trade => {
        // Only show premium per share for covered call trades
        return trade.tradeType === 'covered-call' ? (trade.premium || 0) / (trade.shares || 1) : 0;
      });
      
      // Calculate adjusted cost basis for each trade (cumulative for covered calls)
      const costBasisData = sortedTrades.map((trade, index) => {
        console.log(`Chart - Trade: ${trade.symbol} ${trade.tradeType}, newCostBasis: ${trade.newCostBasis}, originalCostBasis: ${trade.originalCostBasis}`);
        
        if (trade.tradeType === 'shares') {
          console.log(`Chart - Share purchase, returning original cost basis: ${trade.originalCostBasis}`);
          return trade.originalCostBasis;
        } else {
          console.log(`Chart - Covered call trade, calculating cumulative cost basis...`);
          // For covered calls, calculate cumulative cost basis up to this point
          const symbolTrades = sortedTrades.filter(t => t.symbol === trade.symbol && new Date(t.dateAdded) <= new Date(trade.dateAdded));
          console.log(`Chart - Symbol trades for ${trade.symbol}:`, symbolTrades.length);
          console.log(`Chart - All symbol trades:`, symbolTrades);
          
          const sharePurchases = symbolTrades.filter(t => t.tradeType === 'shares');
          console.log(`Chart - Share purchases found:`, sharePurchases.length, sharePurchases);
          
          const totalOriginalCostBasis = sharePurchases
            .reduce((sum, t) => sum + (t.originalCostBasis * t.shares), 0);
          const totalPremiumReceived = symbolTrades
            .filter(t => t.tradeType === 'covered-call')
            .reduce((sum, t) => sum + t.premium, 0);
          const totalShares = symbolTrades
            .filter(t => t.tradeType === 'shares')
            .reduce((sum, t) => sum + t.shares, 0);
          
          console.log(`Chart - Total original cost basis: ${totalOriginalCostBasis}, total premium: ${totalPremiumReceived}, total shares: ${totalShares}`);
          
          if (totalShares > 0) {
            const cumulativeCostBasis = (totalOriginalCostBasis - totalPremiumReceived) / totalShares;
            console.log(`Chart - Cumulative calculation for ${trade.symbol}: (${totalOriginalCostBasis} - ${totalPremiumReceived}) / ${totalShares} = ${cumulativeCostBasis}`);
            return cumulativeCostBasis;
          }
          console.log(`Chart - No shares found, returning original cost basis: ${trade.originalCostBasis}`);
          return trade.originalCostBasis;
        }
      });
      
      console.log('Chart costBasisData:', costBasisData);
      
      const currentPriceData = sortedTrades.map(trade => {
        // For share purchases, use cost basis as current price if no current price
        if (trade.tradeType === 'share-purchase') {
          return trade.currentPrice || trade.newCostBasis;
        }
        return trade.currentPrice || 0;
      });

      // Calculate total cost basis, total adjusted cost basis, and total premium for line chart
      const totalCostBasisData = sortedTrades.map((trade, index) => {
        const symbolTrades = sortedTrades.filter(t => t.symbol === trade.symbol && new Date(t.dateAdded) <= new Date(trade.dateAdded));
        const sharePurchases = symbolTrades.filter(t => t.tradeType === 'shares');
        return sharePurchases.reduce((sum, t) => sum + (t.originalCostBasis * t.shares), 0);
      });

      const totalAdjustedCostBasisData = sortedTrades.map((trade, index) => {
        const symbolTrades = sortedTrades.filter(t => t.symbol === trade.symbol && new Date(t.dateAdded) <= new Date(trade.dateAdded));
        const sharePurchases = symbolTrades.filter(t => t.tradeType === 'shares');
        const totalOriginalCostBasis = sharePurchases.reduce((sum, t) => sum + (t.originalCostBasis * t.shares), 0);
        const totalPremiumReceived = symbolTrades
          .filter(t => t.tradeType === 'covered-call')
          .reduce((sum, t) => sum + (t.premium || 0), 0);
        return totalOriginalCostBasis - totalPremiumReceived;
      });

      const totalPremiumData = sortedTrades.map((trade, index) => {
        const symbolTrades = sortedTrades.filter(t => t.symbol === trade.symbol && new Date(t.dateAdded) <= new Date(trade.dateAdded));
        return symbolTrades
          .filter(t => t.tradeType === 'covered-call')
          .reduce((sum, t) => sum + (t.premium || 0), 0);
      });

      // Calculate pie chart data - portfolio breakdown by value
      const totalPortfolioValue = totalCostBasisData[totalCostBasisData.length - 1] || 0;
      const totalPremiumEarned = totalPremiumData[totalPremiumData.length - 1] || 0;
      const totalValue = totalPortfolioValue + totalPremiumEarned;
      
      const pieData = totalValue > 0 ? [
        {
          label: 'Share Value',
          value: totalPortfolioValue,
          percentage: (totalPortfolioValue / totalValue * 100).toFixed(1)
        },
        {
          label: 'Premium Earned',
          value: totalPremiumEarned,
          percentage: (totalPremiumEarned / totalValue * 100).toFixed(1)
        }
      ] : [
        {
          label: 'No Data',
          value: 1,
          percentage: '100.0'
        }
      ];

      const datasets = chartType === 'bar' ? [
        {
          label: 'Premium Received',
          data: premiumData,
          backgroundColor: 'rgba(102, 126, 234, 0.8)',
          borderColor: 'rgba(102, 126, 234, 1)',
          borderWidth: 1,
          fill: false,
          tension: 0
        },
        {
          label: 'Adjusted Cost Basis',
          data: costBasisData,
          backgroundColor: 'rgba(40, 167, 69, 0.8)',
          borderColor: 'rgba(40, 167, 69, 1)',
          borderWidth: 1,
          fill: false,
          tension: 0
        },
        {
          label: 'Current Price',
          data: currentPriceData,
          backgroundColor: 'rgba(255, 193, 7, 0.8)',
          borderColor: 'rgba(255, 193, 7, 1)',
          borderWidth: 1,
          fill: false,
          tension: 0
        }
      ] : chartType === 'line' ? [
        {
          label: 'Original Cost Basis',
          data: totalCostBasisData,
          backgroundColor: 'rgba(0, 123, 255, 1)',
          borderColor: 'rgba(0, 123, 255, 1)',
          borderWidth: 3,
          fill: false,
          tension: 0.4,
          pointBackgroundColor: 'rgba(0, 123, 255, 1)',
          pointBorderColor: 'rgba(0, 123, 255, 1)',
          pointRadius: 6,
          pointHoverRadius: 8
        },
        {
          label: 'Total Adjusted Cost Basis',
          data: totalAdjustedCostBasisData,
          backgroundColor: 'rgba(40, 167, 69, 1)',
          borderColor: 'rgba(40, 167, 69, 1)',
          borderWidth: 3,
          fill: false,
          tension: 0.4,
          pointBackgroundColor: 'rgba(40, 167, 69, 1)',
          pointBorderColor: 'rgba(40, 167, 69, 1)',
          pointRadius: 6,
          pointHoverRadius: 8
        },
        {
          label: 'Total Premium Received',
          data: totalPremiumData,
          backgroundColor: 'rgba(255, 99, 132, 1)',
          borderColor: 'rgba(255, 99, 132, 1)',
          borderWidth: 3,
          fill: false,
          tension: 0.4,
          pointBackgroundColor: 'rgba(255, 99, 132, 1)',
          pointBorderColor: 'rgba(255, 99, 132, 1)',
          pointRadius: 6,
          pointHoverRadius: 8
        }
      ] : [
        {
          label: pieData[0].label,
          data: [pieData[0].value],
          backgroundColor: ['rgba(40, 167, 69, 0.8)'],
          borderColor: ['rgba(40, 167, 69, 1)'],
          borderWidth: 2
        },
        {
          label: pieData[1].label,
          data: [pieData[1].value],
          backgroundColor: ['rgba(255, 99, 132, 0.8)'],
          borderColor: ['rgba(255, 99, 132, 1)'],
          borderWidth: 2
        }
      ];

      const chartData = chartType === 'pie' ? {
        labels: pieData.map(item => item.label),
        datasets: [{
          data: pieData.map(item => item.value),
          backgroundColor: [
            'rgba(40, 167, 69, 0.8)',
            'rgba(255, 99, 132, 0.8)'
          ],
          borderColor: [
            'rgba(40, 167, 69, 1)',
            'rgba(255, 99, 132, 1)'
          ],
          borderWidth: 2
        }]
      } : {
        labels: labels,
        datasets: datasets
      };

      performanceChart = new Chart(ctx, {
        type: chartType,
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              callbacks: {
                title: function(context) {
                  if (chartType === 'pie') {
                    return context[0].label;
                  }
                  const index = context[0].dataIndex;
                  return tooltipLabels[index];
                },
                label: function(context) {
                  if (chartType === 'pie') {
                    const item = pieData[context.dataIndex];
                    return `${item.label}: $${item.value.toFixed(2)} (${item.percentage}%)`;
                  }
                  return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                }
              }
            }
          },
          scales: chartType === 'pie' ? {} : {
            y: {
              beginAtZero: true,
              ticks: {
                callback: function(value) {
                  return '$' + value.toFixed(2);
                }
              }
            }
          },
          plugins: {
            legend: {
              position: 'top',
              onClick: chartType === 'pie' ? function(e, legendItem, legend) {
                const index = legendItem.datasetIndex;
                const chart = legend.chart;
                
                // Toggle the dataset visibility
                if (chart.isDatasetVisible(index)) {
                  chart.hide(index);
                } else {
                  chart.show(index);
                }
                
                // Recalculate percentages for visible slices
                updatePieChartPercentages(chart);
              } : undefined
            },
            title: {
              display: true,
              text: chartType === 'pie' ? 'Portfolio Breakdown' : 'Covered Call Performance'
            }
          }
        }
      });
    }

    // Update pie chart percentages when slices are hidden/shown
    function updatePieChartPercentages(chart) {
      if (chartType !== 'pie') return;
      
      const data = chart.data.datasets[0].data;
      const labels = chart.data.labels;
      const visibleData = [];
      const visibleIndices = [];
      
      // Get visible data points
      for (let i = 0; i < data.length; i++) {
        if (chart.getDataVisibility(i)) {
          visibleData.push(data[i]);
          visibleIndices.push(i);
        }
      }
      
      // Calculate total of visible data
      const totalVisible = visibleData.reduce((sum, value) => sum + value, 0);
      
      // Update labels with recalculated percentages
      if (totalVisible > 0) {
        for (let i = 0; i < labels.length; i++) {
          if (chart.getDataVisibility(i)) {
            const percentage = ((data[i] / totalVisible) * 100).toFixed(1);
            const originalLabel = labels[i].split(' (')[0]; // Remove existing percentage
            labels[i] = `${originalLabel} (${percentage}%)`;
          }
        }
      }
      
      chart.update();
    }

    // Update table
    function updateTable() {
      const tbody = document.getElementById('tradesTableBody');
      
      if (trades.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="8" style="text-align: center; color: #666; padding: 2rem;">
              No trades yet. Add your first trade above!
            </td>
          </tr>
        `;
        return;
      }

      tbody.innerHTML = trades.map(trade => `
        <tr>
          <td>
            <span style="padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.8rem; font-weight: bold; 
                        background: ${trade.tradeType === 'shares' ? '#e3f2fd' : '#f3e5f5'}; 
                        color: ${trade.tradeType === 'shares' ? '#1976d2' : '#7b1fa2'};">
              ${trade.tradeType === 'shares' ? 'SHARES' : 'CALL'}
            </span>
          </td>
          <td><strong>${trade.symbol}</strong></td>
          <td>${trade.shares}</td>
          <td>${trade.strikePrice ? '$' + trade.strikePrice.toFixed(2) : '-'}</td>
          <td>${trade.premium ? '$' + (trade.premium / trade.shares).toFixed(2) : '-'}</td>
          <td>$${trade.newCostBasis.toFixed(2)}</td>
          <td class="${trade.pnl >= 0 ? 'profit' : 'loss'}">
            ${trade.pnl >= 0 ? '+' : ''}$${trade.pnl.toFixed(2)}
          </td>
          <td>
            <div class="action-buttons">
              <button class="btn btn-danger btn-sm" onclick="deleteTrade(${trade.id})">Delete</button>
            </div>
          </td>
        </tr>
      `).join('');
    }

    // Delete trade
    function deleteTrade(id) {
      if (confirm('Are you sure you want to delete this trade?')) {
        trades = trades.filter(trade => trade.id !== id);
        localStorage.setItem('coveredCallTrades', JSON.stringify(trades));
        loadTrades();
        updateStats();
        updateChart();
        updateTable();
      }
    }

     // Clear form
     function clearForm() {
       const tradeType = document.getElementById('tradeType').value;
       const selectedSymbol = document.getElementById('symbolSelect').value;
       
       // Reset the form
       document.getElementById('tradeForm').reset();
       
       // If it was a covered call trade, keep it selected and restore the position
       if (tradeType === 'covered-call' && selectedSymbol) {
         document.getElementById('tradeType').value = 'covered-call';
         toggleSymbolFields(); // This will show the covered call fields
         
         // Restore the selected position after a short delay to ensure the dropdown is populated
         setTimeout(() => {
           document.getElementById('symbolSelect').value = selectedSymbol;
           loadSelectedPosition();
         }, 100);
       } else {
         // For share purchases, reset to default and set today's date
         const today = new Date().toISOString().split('T')[0];
         document.getElementById('tradeDate').value = today;
       }
     }

    // Clear all data
    function clearAllData() {
      if (confirm('Are you sure you want to delete ALL trades? This cannot be undone.')) {
        trades = [];
        localStorage.removeItem('coveredCallTrades');
        loadTrades();
        updateStats();
        updateChart();
        updateTable();
      }
    }

    // Fetch current stock price using Yahoo Finance API
    async function fetchCurrentPrice() {
      const symbol = document.getElementById('symbol').value.trim().toUpperCase();
      const currentPriceInput = document.getElementById('currentPrice');
      
      if (!symbol) {
        alert('Please enter a stock symbol first');
        return;
      }

      // Show loading state
      const button = event.target;
      const originalText = button.textContent;
      button.textContent = 'Loading...';
      button.disabled = true;

      try {
        const response = await fetch(`https://query1.finance.yahoo.com/v8/finance/chart/${symbol}`);
        const data = await response.json();
        
        if (data.chart && data.chart.result && data.chart.result[0]) {
          const price = data.chart.result[0].meta.regularMarketPrice;
          currentPriceInput.value = price.toFixed(2);
          alert(`Current price for ${symbol}: $${price.toFixed(2)}`);
        } else {
          throw new Error('Price data not available');
        }
      } catch (error) {
        console.error('Error fetching stock price:', error);
        alert(`Unable to fetch current price for ${symbol}. Please enter manually.`);
      } finally {
        // Reset button state
        button.textContent = originalText;
        button.disabled = false;
      }
    }

    // Export data
    function exportData() {
      if (trades.length === 0) {
        alert('No data to export!');
        return;
      }

      const csvContent = [
        ['Symbol', 'Shares', 'Original Cost Basis', 'New Cost Basis', 'Strike Price', 'Premium', 'Current Price', 'P&L', 'Expiration Date', 'Notes', 'Date Added'],
        ...trades.map(trade => [
          trade.symbol,
          trade.shares,
          trade.originalCostBasis,
          trade.newCostBasis,
          trade.strikePrice,
          trade.premium,
          trade.currentPrice,
          trade.pnl,
          trade.expirationDate,
          trade.notes,
          new Date(trade.dateAdded).toLocaleDateString()
        ])
      ].map(row => row.join(',')).join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'covered-call-trades.csv';
      a.click();
      window.URL.revokeObjectURL(url);
    }

    // Theme toggle functionality
    const themeToggle = document.createElement('button');
    themeToggle.innerHTML = 'üåô';
    themeToggle.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: white;
      font-size: 1.5rem;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    `;

    let isDarkTheme = false;

    themeToggle.addEventListener("click", () => {
      isDarkTheme = !isDarkTheme;
      if (isDarkTheme) {
        document.body.classList.add("dark-theme");
        themeToggle.textContent = "‚òÄÔ∏è";
        localStorage.setItem("theme", "dark");
      } else {
        document.body.classList.remove("dark-theme");
        themeToggle.textContent = "üåô";
        localStorage.setItem("theme", "light");
      }
    });

    // Load saved theme on page load
    const savedTheme = localStorage.getItem("theme");
    if (savedTheme === "dark") {
      isDarkTheme = true;
      document.body.classList.add("dark-theme");
      themeToggle.textContent = "‚òÄÔ∏è";
    }

    document.body.appendChild(themeToggle);
  </script>
</body>
</html>
